service:
  name: engstats

provider:
  name: aws
  runtime: nodejs12.x
  stackName: ${self:service}-${self:provider.stage}-${env:AWS_REGION}
  stage: ${env:STAGE}
  region: ${env:AWS_REGION}
  iamRoleStatements:
    - Effect: Allow
      Action: "*"
      Resource: "*"

  apiGateway:
    restApiId: 
      Ref: ApiGatewayRestApi
    restApiResources:
      Fn::GetAtt:
        - ApiGatewayRestApi
        - RootResourceId
  tracing:
    lambda: true # Optional, can be true (true equals 'Active'), 'Active' or 'PassThrough'

custom:
  RDS:
    clusterIdentifierName: ${self:provider.stackName}-aurora-cluster
    clusterDatabaseSecretName: ${self:custom.RDS.clusterIdentifierName}-secret
    databaseName: ${self:service} # rds requires alphanumeric database names
    databaseUser: ${self:service}
  GraphQL:
    path: '/graphql'
  Network:
    VpcCIDR: '10.192.0.0/16'
    PublicSubnet0CIDR: '10.192.10.0/24'
    PublicSubnet1CIDR: '10.192.11.0/24'
    PublicSubnet2CIDR: '10.192.12.0/24'
    PublicSubnet3CIDR: '10.192.13.0/24'
    PublicSubnet4CIDR: '10.192.14.0/24'
    PublicSubnet5CIDR: '10.192.15.0/24'

plugins:
  - serverless-offline
  - serverless-pseudo-parameters

functions:
  graphql:
    handler: src/handler.handler
    timeout: 30
    events:
      - http:
          path: ${self:custom.GraphQL.path}
          method: post
          cors: true
    environment:
      SECRET_ARN: ${ssm:/${self:provider.stackName}/SECRET_ARN_SSM, !Ref DatabaseSecret }  # ${opt:stage, self:provider.stage}, consider overrides
      # SECRET_ARN: ${ssm:/${self:provider.stackName}/SECRET_ARN_SSM} # Hack 1
      DB_ARN: arn:aws:rds:${self:provider.region}:${env:AWS_ACCOUNT_ID}:cluster:${self:custom.RDS.clusterIdentifierName}
      DATABASE_NAME: ${self:custom.RDS.databaseName}
      DATABASE_USER: ${self:custom.RDS.databaseUser}
      DATABASE_HOSTNAME: !GetAtt 'DatabaseCluster.Endpoint.Address'
      DATABASE_PORT: !GetAtt 'DatabaseCluster.Endpoint.Port'
    dependsOn: 
      - SecretARNSSM # Hack 1

resources:
  Conditions:
    BastionEnabled:
      Fn::Equals:
        - ${env:BASTION}
        - 'true'

  Resources:
    ApiGatewayRestApi:
      Type: AWS::ApiGateway::RestApi
      Properties:
        Name: ${self:provider.stackName}-api

    DatabaseSecret:
      Type: AWS::SecretsManager::Secret
      Properties:
        Name: ${self:custom.RDS.clusterDatabaseSecretName}
        Description: 'Used to access aurora serverless instance'
        GenerateSecretString:
          SecretStringTemplate: '{"username": "${self:custom.RDS.databaseUser}"}'
          GenerateStringKey: 'password'
          PasswordLength: 16
          ExcludeCharacters: '"@/'

    DatabaseCluster:
      Type: AWS::RDS::DBCluster
      Properties:
        DatabaseName: ${self:custom.RDS.databaseName}
        MasterUsername:
          Fn::Join: ['', ['{{resolve:secretsmanager:', { Ref: DatabaseSecret }, ':SecretString:username}}' ]]
        MasterUserPassword:
          Fn::Join: ['', ['{{resolve:secretsmanager:', { Ref: DatabaseSecret }, ':SecretString:password}}' ]]
        DBClusterIdentifier: ${self:custom.RDS.clusterIdentifierName}
        Engine: aurora-postgresql
        EngineMode: serverless
        EnableHttpEndpoint: true # DataAPI - https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html
        ScalingConfiguration:
          AutoPause: true
          MaxCapacity: 16
          MinCapacity: 2
          SecondsUntilAutoPause: 3600
        DBSubnetGroupName: !Ref "MyDBSubnetGroup"
        VpcSecurityGroupIds: # DBSecurityGroups vs VPCSecurityGroups vs VpcSecurityGroupIds
          - !GetAtt DatabaseVPCSecurityGroup.GroupId

    SecretRDSInstanceAttachment:
      Type: AWS::SecretsManager::SecretTargetAttachment
      Properties:
        SecretId: { Ref: DatabaseSecret }
        TargetId: { Ref: DatabaseCluster }
        TargetType: AWS::RDS::DBCluster
    
    ###############
    # Hack 1 
    ###############
    # Serverless offline does not allow you to use Ref, which our lambda depends on the secret ARN
    #   We can save the value on the first deploy in SSM, and then use the SSM value in serverless offline
    # https://github.com/dherault/serverless-offline/issues/688
    SecretARNSSM:
      Type: AWS::SSM::Parameter
      Properties: 
        Type: String
        Name: "/${self:provider.stackName}/SECRET_ARN_SSM"
        Value: { Ref: DatabaseSecret }

    ################
    # Bastion
    ################
    BastionSecurityGroup:
      Type: AWS::EC2::SecurityGroup
      Condition: BastionEnabled
      Properties: 
        GroupDescription: 'Bastion for ${self:provider.stackName}'
        SecurityGroupEgress:
          - CidrIp: 0.0.0.0/0
            FromPort: -1
            ToPort: -1
            IpProtocol: '-1'
          - DestinationSecurityGroupId: !GetAtt DatabaseVPCSecurityGroup.GroupId
            IpProtocol: tcp
            FromPort: !GetAtt 'DatabaseCluster.Endpoint.Port'
            ToPort: !GetAtt 'DatabaseCluster.Endpoint.Port'
        
        # TODO: Change this, it is not secure (Should only need Port 22)
        SecurityGroupIngress:
          - CidrIp: 0.0.0.0/0
            FromPort: -1
            ToPort: -1
            IpProtocol: '-1'
        VpcId: { Ref: VPC }

    Bastion:
      Type: AWS::EC2::Instance
      Condition: BastionEnabled
      Properties:
        DisableApiTermination: false
        ImageId: ${ssm:/aws/service/ami-amazon-linux-latest/amzn-ami-hvm-x86_64-ebs}
        InstanceType: t2.nano
        KeyName: ${env:EC2_KEY_NAME}
        Monitoring: false
        UserData: !Base64 'yum install postgresql --assumeyes'
        NetworkInterfaces: 
          - AssociatePublicIpAddress: "true"
            DeviceIndex: "0"
            GroupSet: 
              - Ref: "DatabaseVPCSecurityGroup"
              - Ref: "BastionSecurityGroup"
            SubnetId: { Ref: "PublicSubnet0" }

    ################
    # Networking
    ################
    VPC:
      Type: AWS::EC2::VPC
      Properties:
        CidrBlock: ${self:custom.Network.VpcCIDR}
        EnableDnsSupport: true
        EnableDnsHostnames: true
        Tags:
          - Key: Name
            Value: ${self:provider.stackName}

    DatabaseVPCSecurityGroup: 
      Type: AWS::EC2::SecurityGroup
      Properties:
        VpcId: { Ref: VPC }
        GroupDescription: "Ingress for Amazon EC2 security group"

        # Change this, it is not secure, might only need Bastion hosts' 
        SecurityGroupIngress:
          -
            IpProtocol: "tcp"
            CidrIp: "0.0.0.0/0" # FIX THIS
            FromPort: 5432
            ToPort: 5432

    InternetGateway:
      Type: AWS::EC2::InternetGateway
      Properties:
        Tags:
          - Key: Name
            Value: ${self:provider.stackName}

    InternetGatewayAttachment:
      Type: AWS::EC2::VPCGatewayAttachment
      Properties:
        InternetGatewayId: { Ref: InternetGateway }
        VpcId: { Ref: VPC }

    MyDBSubnetGroup:
      Type: AWS::RDS::DBSubnetGroup
      DependsOn: # Consider if this is actually needed
        - PublicSubnet0RouteTableAssociation
        - PublicSubnet1RouteTableAssociation
        - PublicSubnet2RouteTableAssociation
        - PublicSubnet3RouteTableAssociation
        - PublicSubnet4RouteTableAssociation
      Properties: 
        DBSubnetGroupDescription: DBSubnetGroupDescription
        SubnetIds: 
          - { Ref: PublicSubnet0 }
          - { Ref: PublicSubnet1 }
          - { Ref: PublicSubnet2 }
          - { Ref: PublicSubnet3 }
          - { Ref: PublicSubnet4 }
          - { Ref: PublicSubnet5 }

    PublicSubnet0:
      Type: AWS::EC2::Subnet
      Properties:
        VpcId: { Ref: VPC }
        AvailabilityZone: !Select [ 0, !GetAZs '' ]
        CidrBlock: ${self:custom.Network.PublicSubnet0CIDR}
        MapPublicIpOnLaunch: true
        Tags:
          - Key: Name
            Value: "${self:provider.stackName} Public Subnet (AZ0)"

    PublicSubnet1:
      Type: AWS::EC2::Subnet
      Properties:
        VpcId: { Ref: VPC }
        AvailabilityZone: !Select [ 1, !GetAZs '' ]
        CidrBlock: ${self:custom.Network.PublicSubnet1CIDR}
        MapPublicIpOnLaunch: true
        Tags:
          - Key: Name
            Value: "${self:provider.stackName} Public Subnet (AZ1)"

    PublicSubnet2:
      Type: AWS::EC2::Subnet
      Properties:
        VpcId: { Ref: VPC }
        AvailabilityZone: !Select [ 2, !GetAZs '' ]
        CidrBlock: ${self:custom.Network.PublicSubnet2CIDR}
        MapPublicIpOnLaunch: true
        Tags:
          - Key: Name
            Value: "${self:provider.stackName} Public Subnet (AZ2)"

    PublicSubnet3:
      Type: AWS::EC2::Subnet
      Properties:
        VpcId: { Ref: VPC }
        AvailabilityZone: !Select [ 3, !GetAZs '' ]
        CidrBlock: ${self:custom.Network.PublicSubnet3CIDR}
        MapPublicIpOnLaunch: true
        Tags:
          - Key: Name
            Value: "${self:provider.stackName} Public Subnet (AZ3)"

    PublicSubnet4:
      Type: AWS::EC2::Subnet
      Properties:
        VpcId: { Ref: VPC }
        AvailabilityZone: !Select [ 4, !GetAZs '' ]
        CidrBlock: ${self:custom.Network.PublicSubnet4CIDR}
        MapPublicIpOnLaunch: true
        Tags:
          - Key: Name
            Value: "${self:provider.stackName} Public Subnet (AZ4)"

    PublicSubnet5:
      Type: AWS::EC2::Subnet
      Properties:
        VpcId: { Ref: VPC }
        AvailabilityZone: !Select [ 5, !GetAZs '' ]
        CidrBlock: ${self:custom.Network.PublicSubnet5CIDR}
        MapPublicIpOnLaunch: true
        Tags:
          - Key: Name
            Value: "${self:provider.stackName} Public Subnet (AZ5)"          

    PublicRouteTable:
      Type: AWS::EC2::RouteTable
      Properties:
        VpcId: { Ref: VPC }
        Tags:
          - Key: Name
            Value: "${self:provider.stackName} Public Routes"

    DefaultPublicRoute:
      Type: AWS::EC2::Route
      DependsOn: InternetGatewayAttachment
      Properties:
        RouteTableId: { Ref: PublicRouteTable }
        DestinationCidrBlock: 0.0.0.0/0
        GatewayId: { Ref: InternetGateway }

    PublicSubnet0RouteTableAssociation:
      Type: AWS::EC2::SubnetRouteTableAssociation
      Properties:
        RouteTableId: { Ref: PublicRouteTable }
        SubnetId: { Ref: PublicSubnet0 }

    PublicSubnet1RouteTableAssociation:
      Type: AWS::EC2::SubnetRouteTableAssociation
      Properties:
        RouteTableId: { Ref: PublicRouteTable }
        SubnetId: { Ref: PublicSubnet1 }

    PublicSubnet2RouteTableAssociation:
      Type: AWS::EC2::SubnetRouteTableAssociation
      Properties:
        RouteTableId: { Ref: PublicRouteTable }
        SubnetId: { Ref: PublicSubnet2 }

    PublicSubnet3RouteTableAssociation:
      Type: AWS::EC2::SubnetRouteTableAssociation
      Properties:
        RouteTableId: { Ref: PublicRouteTable }
        SubnetId: { Ref: PublicSubnet3 }

    PublicSubnet4RouteTableAssociation:
      Type: AWS::EC2::SubnetRouteTableAssociation
      Properties:
        RouteTableId: { Ref: PublicRouteTable }
        SubnetId: { Ref: PublicSubnet4 }

    PublicSubnet5RouteTableAssociation:
      Type: AWS::EC2::SubnetRouteTableAssociation
      Properties:
        RouteTableId: { Ref: PublicRouteTable }
        SubnetId: { Ref: PublicSubnet5 }

  ################
  # Outputs
  ################

  Outputs:
    GraphQLUrl:
      Value:
        Fn::Join:
        - ""
        - - "https://"
          - Ref: "ApiGatewayRestApi"
          - ".execute-api."
          - ${self:provider.region}.
          - Ref: "AWS::URLSuffix"
          - "/"
          - ${self:provider.stage}
          - ${self:custom.GraphQL.path}
      Export:
        Name: ${self:provider.stackName}-graphQLUrl

    DatabaseClusterIdentifierName:
      Value:
        { Ref: DatabaseCluster }
      Export:
        Name: ${self:provider.stackName}-databaseClusterIdentifierName

    DatabaseName:
      Value: ${self:custom.RDS.databaseName}
      Export:
        Name: ${self:provider.stackName}-databaseName

    DatabaseSecretArn:
      Value: { Ref: DatabaseSecret }
      Export:
        Name: ${self:provider.stackName}-databaseSecretArn

    DatabaseHostName:
      Description: 'The connection endpoint for the DB cluster.'
      Value: !GetAtt 'DatabaseCluster.Endpoint.Address'
      Export:
        Name: ${self:provider.stackName}-databaseHostName
    
    DatabasePort:
      Description: 'The connection endpoint for the DB cluster.'
      Value: !GetAtt 'DatabaseCluster.Endpoint.Port'
      Export:
        Name: ${self:provider.stackName}-databasePort

    BastionPublicDnsName:
      Condition: BastionEnabled
      Description: 'The connection endpoint for the DB cluster.'
      Value: !GetAtt 'Bastion.PublicDnsName'
      Export:
        Name: ${self:provider.stackName}-PublicDnsName